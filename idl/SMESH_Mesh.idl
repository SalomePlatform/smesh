//  Copyright (C) 2003  OPEN CASCADE, EADS/CCR, LIP6, CEA/DEN,
//  CEDRAT, EDF R&D, LEG, PRINCIPIA R&D, BUREAU VERITAS
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
//
// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
//
//
//
//  File   : SMESH_Mesh.idl
//  Author : Paul RASCLE, EDF
//  $Header$

#ifndef _SMESH_MESH_IDL_
#define _SMESH_MESH_IDL_

#include "SALOME_Exception.idl"
#include "SALOME_GenericObj.idl"
#include "GEOM_Gen.idl"
#include "MED.idl"

module SMESH
{
  interface SMESH_Hypothesis;
  typedef sequence<SMESH_Hypothesis> ListOfHypothesis;
  interface SMESH_GroupBase;
  typedef sequence<SMESH_GroupBase> ListOfGroups;

  typedef sequence<double    > double_array ;
  typedef sequence<long      > long_array ;
  typedef sequence<string    > string_array ;
  typedef sequence<long_array> array_of_long_array ;

  enum log_command
    {
      ADD_NODE,
      ADD_EDGE,
      ADD_TRIANGLE,
      ADD_QUADRANGLE,
      ADD_POLYGON,
      ADD_TETRAHEDRON,
      ADD_PYRAMID,
      ADD_PRISM,
      ADD_HEXAHEDRON,
      ADD_POLYHEDRON,
      REMOVE_NODE,
      REMOVE_ELEMENT,
      MOVE_NODE,
      CHANGE_ELEMENT_NODES,
      CHANGE_POLYHEDRON_NODES,
      RENUMBER,
      ADD_QUADEDGE,
      ADD_QUADTRIANGLE,
      ADD_QUADQUADRANGLE,
      ADD_QUADTETRAHEDRON,
      ADD_QUADPYRAMID,
      ADD_QUADPENTAHEDRON,
      ADD_QUADHEXAHEDRON
    };

  struct log_block
  {
    long commandType;
    long number;
    double_array coords;
    long_array indexes;
  };

  struct PointStruct { double x;
  		       double y;
  		       double z; } ;

  typedef sequence<PointStruct> nodes_array;

  struct DirStruct   { PointStruct PS ; } ;          // analog to Occ Direction

  struct AxisStruct  { double x;
  		       double y;
  		       double z;
  		       double vx;
  		       double vy;
  		       double vz; } ;


  /*!
   * Enumeration for element type, like in SMDS
   */
  enum ElementType
  {
    ALL,
    NODE,
    EDGE,
    FACE,
    VOLUME
  };
  
  /*!
   * Structure used in mesh edit preview data
   */
  struct ElementSubType { ElementType SMDS_ElementType;
                          boolean     isPoly;
                          long        nbNodesInElement; };

  typedef sequence<ElementSubType> types_array;

  /*!
   * Structure containing mesh edit preview data
   */
  struct MeshPreviewStruct { nodes_array nodesXYZ;
                             long_array  elementConnectivities;
                             types_array elementTypes; };

  /*!
   * ElementOrder points out entities of what order are requested
   */
  enum ElementOrder {
    ORDER_ANY,          /*! entities of any order */
    ORDER_LINEAR,       /*! entities of 1st order */
    ORDER_QUADRATIC     /*! entities of 2nd order */
  };

  /*!
   * Enumeration for hypothesis status (used by AddHypothesis() and RemoveHypothesis() methods)
   */
  enum Hypothesis_Status // in the order of severity
  {
    HYP_OK,
    HYP_MISSING,      // algo misses a hypothesis
    HYP_CONCURENT,    // several applicable hypotheses
    HYP_BAD_PARAMETER,// hypothesis has a bad parameter value
    HYP_HIDDEN_ALGO,  // an algo is hidden by an upper dim algo generating all-dim elements
    HYP_HIDING_ALGO,  // an algo hides lower dim algos by generating all-dim elements
    HYP_UNKNOWN_FATAL,//  --- all statuses below should be considered as fatal
                      //      for Add/RemoveHypothesis operations
    HYP_INCOMPATIBLE, // hypothesis does not fit algo
    HYP_NOTCONFORM,   // not conform mesh is produced appling a hypothesis
    HYP_ALREADY_EXIST,// such hypothesis already exist
    HYP_BAD_DIM,      // bad dimension
    HYP_BAD_SUBSHAPE, // shape is neither the main one, nor its subshape, nor a group
    HYP_BAD_GEOMETRY  // geometry mismatches algorithm's expectation
  };

  /*!
   * Enumeration for DriverMED read status (used by ImportMEDFile() method)
   */
  enum DriverMED_ReadStatus // in the order of severity
  {
    DRS_OK,
    DRS_EMPTY,          // a MED file contains no mesh with the given name
    DRS_WARN_RENUMBER,  // a MED file has overlapped ranges of element numbers,
                        // so the numbers from the file are ignored
    DRS_WARN_SKIP_ELEM, // some elements were skipped due to incorrect file data
    DRS_FAIL            // general failure (exception etc.)
  };

  /*!
   * Enumeration for DriverMED (used by Perform() method)
   */
  enum MED_VERSION // in the order of severity
  {
    MED_V2_1,
    MED_V2_2
  };

  typedef sequence<log_block> log_array;


  /*!
   * Auxilary flags for advanced extrusion.
   * BOUNDARY: create or not boundary for result of extrusion
   * SEW:      try to use existing nodes or create new nodes in any case
   */
  const long EXTRUSION_FLAG_BOUNDARY = 1;
  const long EXTRUSION_FLAG_SEW = 2;
  
  interface SMESH_IDSource
  {
    /*!
     * Returns a sequence of all element IDs
     */
    long_array GetIDs();
  };

  interface SMESH_Group;
  interface SMESH_GroupOnGeom;
  interface SMESH_subMesh;
  interface SMESH_MeshEditor;
  interface SMESH_Mesh : SALOME::GenericObj, SMESH_IDSource
  {
    /*!
     * Return true if there is a geometry to be meshed
     */
    boolean HasShapeToMesh()
      raises (SALOME::SALOME_Exception);

    /*!
     * Get geom shape to mesh. A result sould not be nil. Use HasShapeToMesh()
     * to know if a returned shape 
     */
    GEOM::GEOM_Object GetShapeToMesh()
      raises (SALOME::SALOME_Exception);


    /*!
     * Get the subMesh object associated to a subShape. The subMesh object
     * gives access to nodes and elements IDs.
     * SubMesh will be used instead of SubShape in a next idl version to
     * adress a specific subMesh...
     */
    SMESH_subMesh GetSubMesh(in GEOM::GEOM_Object aSubObject, in string name)
      raises (SALOME::SALOME_Exception);

    /*!
     * Remove a submesh
     */
    void RemoveSubMesh(in SMESH_subMesh aSubMesh)
      raises (SALOME::SALOME_Exception);


    /*!
     * Create a group
     */
    SMESH_Group CreateGroup( in ElementType elem_type,
			     in string name )
      raises (SALOME::SALOME_Exception);

    /*!
     * Create a group from geometry group
     */
    SMESH_GroupOnGeom CreateGroupFromGEOM( in ElementType elem_type,
                                          in string name,
                                          in GEOM::GEOM_Object theGeomObject )
      raises (SALOME::SALOME_Exception);

    /*!
     * Remove a group
     */
    void RemoveGroup(in SMESH_GroupBase aGroup)
      raises (SALOME::SALOME_Exception);

    /*!
     *  Remove group with its contents
     */
    void RemoveGroupWithContents( in SMESH_GroupBase aGroup )
      raises (SALOME::SALOME_Exception);

    /*!
     *  Get the list of groups existing in the mesh
     */
    ListOfGroups GetGroups()
      raises (SALOME::SALOME_Exception);

    /*!
     * Union of two groups
     *    New group is created. All mesh elements that are
     *    present in initial groups are added to the new one
     */
    SMESH_Group UnionGroups (in SMESH_GroupBase aGroup1,
                             in SMESH_GroupBase aGroup2,
                             in string          name )
      raises (SALOME::SALOME_Exception);

    /*!
     *  Intersection of two groups
     *  New group is created. All mesh elements that are
     *  present in both initial groups are added to the new one.
     */
    SMESH_Group IntersectGroups (in SMESH_GroupBase aGroup1,
                                 in SMESH_GroupBase aGroup2,
                                 in string          name )
      raises (SALOME::SALOME_Exception);

    /*!
     *  Cut of two groups
     *  New group is created. All mesh elements that are present in
     *  main group but do not present in tool group are added to the new one
     */
    SMESH_Group CutGroups (in SMESH_GroupBase aMainGroup,
			   in SMESH_GroupBase aToolGroup,
			   in string          name )
      raises (SALOME::SALOME_Exception);

    /*!
     * Add hypothesis to the mesh, under a particular subShape
     * (or the main shape itself)
     * The Add method is only used to prepare the build of the mesh and store
     * the algorithms and associated parameters.
     * Actual job of mesh the shape is done by MESH_Gen.
     * @params
     * - aSubShape : subShape obtained by a shape explode in GEOM
     *   (or main shape)
     * - anHyp : hypothesis object
     * @return
     * - OK if the hypothesis is compatible with the subShape
     *   (and all previous hypothesis on the subShape)
     * - NOK if the hypothesis is not compatible with the subShape
     *   (or one previous hypothesis on the subShape)
     * raises exception if hypothesis has not been created
     */
    Hypothesis_Status AddHypothesis(in GEOM::GEOM_Object aSubObject,
				    in SMESH_Hypothesis anHyp)
      raises (SALOME::SALOME_Exception);
//     boolean AddHypothesis(in SMESH_subMesh aSubMesh, in SMESH_Hypothesis anHyp)
//       raises (SALOME::SALOME_Exception);

    /*!
     * Remove an hypothesis previouly added with AddHypothesis.
     */
    Hypothesis_Status RemoveHypothesis(in GEOM::GEOM_Object aSubObject,
				       in SMESH_Hypothesis anHyp)
      raises (SALOME::SALOME_Exception);
//     boolean RemoveHypothesis(in SMESH_subMesh aSubMesh,
// 			     in SMESH_Hypothesis anHyp)
//       raises (SALOME::SALOME_Exception);

    /*!
     * Get the list of hypothesis added on a subShape
     */
    ListOfHypothesis GetHypothesisList(in GEOM::GEOM_Object aSubObject)
      raises (SALOME::SALOME_Exception);
//     ListOfHypothesis GetHypothesisList(in SMESH_subMesh aSubMesh)
//       raises (SALOME::SALOME_Exception);

    /*!
     * Get the log of nodes and elements added or removed since previous
     * clear of the log.
     * @params
     * - clearAfterGet : log is emptied after Get (safe if concurrents access)
     */
    //    string_array GetLog(in boolean clearAfterGet)
    //      raises (SALOME::SALOME_Exception);
    log_array GetLog(in boolean clearAfterGet)
      raises (SALOME::SALOME_Exception);

    /*!
     * Clear the log of nodes and elements added or removed since previous
     * clear. Must be used immediately after GetLog if clearAfterGet is false.
     */
    void ClearLog()
      raises (SALOME::SALOME_Exception);

    /*!
     * Get the internal Id
     */
    long GetId();

    /*!
     * Get the study Id
     */
    long GetStudyId();

    /*!
     * Obtain instance of SMESH_MeshEditor
     */
    SMESH_MeshEditor GetMeshEditor()
      raises (SALOME::SALOME_Exception);

    /*!
     * Return SMESH_MeshEditor that would not modify the mesh but
     * fill MeshPreviewStruct
     */
    SMESH_MeshEditor GetMeshEditPreviewer()
      raises (SALOME::SALOME_Exception);

    /*! Check group names for duplications.
     *  Consider maximum group name length stored in MED file.
     */
    boolean HasDuplicatedGroupNamesMED();

    /*!
     * Export Mesh to different MED Formats
     * @params
     * - auto_groups : boolean parameter for creating/not creating
     *   the groups Group_On_All_Nodes, Group_On_All_Faces, ... ;
     *   the typical use is auto_groups=false.
     * - theVersion : define the version of format of MED file, that will be created
     */
    void ExportToMED( in string file, in boolean auto_groups, in MED_VERSION theVersion )
      raises (SALOME::SALOME_Exception);

    /*!
     * Export Mesh to MED_V2_1 MED format
     * Works, just the same as ExportToMED, with MED_VERSION parameter equal to MED_V2_1.
     * The method is kept in order to support old functionality
     */
    void ExportMED( in string file, in boolean auto_groups )
      raises (SALOME::SALOME_Exception);

    /*!
     * Export Mesh to DAT, UNV and STL Formats
     * (UNV supported version is I-DEAS 10)
     */
    void ExportDAT( in string file )
      raises (SALOME::SALOME_Exception);
    void ExportUNV( in string file )
      raises (SALOME::SALOME_Exception);
    void ExportSTL( in string file, in boolean isascii )
      raises (SALOME::SALOME_Exception);

    /*!
     * Get MED Mesh
     */
    SALOME_MED::MESH GetMEDMesh()
      raises (SALOME::SALOME_Exception);

    /*!
     * Get informations about mesh contents
     */
    long NbNodes()
      raises (SALOME::SALOME_Exception);

    long NbElements()
      raises (SALOME::SALOME_Exception);

    long NbEdges()
      raises (SALOME::SALOME_Exception);

    long NbEdgesOfOrder(in ElementOrder order)
      raises (SALOME::SALOME_Exception);

    long NbFaces()
      raises (SALOME::SALOME_Exception);

    long NbFacesOfOrder(in ElementOrder order)
      raises (SALOME::SALOME_Exception);

    long NbTriangles()
      raises (SALOME::SALOME_Exception);

    long NbTrianglesOfOrder(in ElementOrder order)
      raises (SALOME::SALOME_Exception);

    long NbQuadrangles()
      raises (SALOME::SALOME_Exception);

    long NbQuadranglesOfOrder(in ElementOrder order)
      raises (SALOME::SALOME_Exception);

    long NbPolygons()
      raises (SALOME::SALOME_Exception);

    long NbVolumes()
      raises (SALOME::SALOME_Exception);

    long NbVolumesOfOrder(in ElementOrder order)
      raises (SALOME::SALOME_Exception);

    long NbTetras()
      raises (SALOME::SALOME_Exception);

    long NbTetrasOfOrder(in ElementOrder order)
      raises (SALOME::SALOME_Exception);

    long NbHexas()
      raises (SALOME::SALOME_Exception);

    long NbHexasOfOrder(in ElementOrder order)
      raises (SALOME::SALOME_Exception);

    long NbPyramids()
      raises (SALOME::SALOME_Exception);

    long NbPyramidsOfOrder(in ElementOrder order)
      raises (SALOME::SALOME_Exception);

    long NbPrisms()
      raises (SALOME::SALOME_Exception);

    long NbPrismsOfOrder(in ElementOrder order)
      raises (SALOME::SALOME_Exception);

    long NbPolyhedrons()
      raises (SALOME::SALOME_Exception);

    long NbSubMesh()
      raises (SALOME::SALOME_Exception);

    long_array GetElementsId()
      raises (SALOME::SALOME_Exception);

    long_array GetElementsByType( in ElementType theType )
      raises (SALOME::SALOME_Exception);

    long_array GetNodesId()
      raises (SALOME::SALOME_Exception);
    
    /*!
     * Returns type of mesh element
     */    
    ElementType GetElementType( in long id, in boolean iselem )
      raises (SALOME::SALOME_Exception);

    long_array GetSubMeshElementsId(in long ShapeID)
      raises (SALOME::SALOME_Exception);

    long_array GetSubMeshNodesId(in long ShapeID, in boolean all )
      raises (SALOME::SALOME_Exception);
    
    ElementType GetSubMeshElementType(in long ShapeID)
      raises (SALOME::SALOME_Exception);

    /*!
     * Get mesh description
     */
    string Dump();

    /*!
     * Get mesh pointer
     */
    long GetMeshPtr();

    /*!
     * Get XYZ coordinates of node as list of double
     * If there is not node for given ID - returns empty list
     */
    double_array GetNodeXYZ(in long id);

    /*!
     * For given node returns list of IDs of inverse elements
     * If there is not node for given ID - returns empty list
     */
    long_array GetNodeInverseElements(in long id);

    /*!
     * If given element is node returns IDs of shape from position
     * If there is not node for given ID - returns -1
     */
    long GetShapeID(in long id);

    /*!
     * For given element returns ID of result shape after 
     * ::FindShape() from SMESH_MeshEditor
     * If there is not element for given ID - returns -1
     */
    long GetShapeIDForElem(in long id);

    /*!
     * Returns number of nodes for given element
     * If there is not element for given ID - returns -1
     */
    long GetElemNbNodes(in long id);

    /*!
     * Returns IDs of nodes of given element
     */
    long_array GetElemNodes(in long id);

    /*!
     * Returns ID of node by given index for given element
     * If there is not element for given ID - returns -1
     * If there is not node for given index - returns -2
     */
    long GetElemNode(in long id, in long index);

    /*!
     * Returns true if given node is medium node
     * in given quadratic element
     */
    boolean IsMediumNode(in long ide, in long idn);

    /*!
     * Returns true if given node is medium node
     * in one of quadratic elements
     */
    boolean IsMediumNodeOfAnyElem(in long idn, in ElementType elem_type);

    /*!
     * Returns number of edges for given element
     */
    long ElemNbEdges(in long id);

    /*!
     * Returns number of faces for given element
     */
    long ElemNbFaces(in long id);

    /*!
     * Returns true if given element is polygon
     */
    boolean IsPoly(in long id);

    /*!
     * Returns true if given element is quadratic
     */
    boolean IsQuadratic(in long id);

    /*!
     * Returns XYZ coordinates of bary center for given element
     * as list of double
     * If there is not element for given ID - returns empty list
     */
    double_array BaryCenter(in long id);

  };

  interface SMESH_subMesh : SALOME::GenericObj, SMESH_IDSource
  {
    /*!
     *
     */
    long GetNumberOfElements()
      raises (SALOME::SALOME_Exception);

    /*!
     *
     */
    long GetNumberOfNodes( in boolean all )
      raises (SALOME::SALOME_Exception);

    /*!
     *
     */
    long_array GetElementsId()
      raises (SALOME::SALOME_Exception);

    /*!
     *
     */
    long_array GetElementsByType( in ElementType theType )
      raises (SALOME::SALOME_Exception);
    
    /*!
     * Return type of submesh element
     */
    ElementType GetElementType( in long id, in boolean iselem )
      raises (SALOME::SALOME_Exception);

    /*!
     *
     */
    long_array GetNodesId()
      raises (SALOME::SALOME_Exception);

    /*!
     * Get geom shape the submesh is dedicated to
     */
    GEOM::GEOM_Object GetSubShape()
      raises (SALOME::SALOME_Exception);

    /*!
     * Get SMESH_Mesh which stores nodes coordinates & elements definition
     */
    SMESH_Mesh GetFather()
      raises (SALOME::SALOME_Exception);

    /*!
     * Get the internal Id
     */
    long GetId();

    /*!
     * Get MED subMesh
     */
    SALOME_MED::FAMILY GetFamily()
      raises (SALOME::SALOME_Exception);
  };

  /*!
   * This interface makes modifications on the Mesh - removing elements and nodes etc.
   */
  interface NumericalFunctor;
  interface SMESH_MeshEditor
  {
    boolean RemoveElements(in long_array IDsOfElements);

    boolean RemoveNodes(in long_array IDsOfNodes);

    long AddNode(in double x, in double y, in double z);

    /*!
     *  Create edge, either linear and quadratic (this is determed
     *  by number of given nodes).
     *  \param IdsOfNodes List of node IDs for creation of element.
     *  Needed order of nodes in this list corresponds to description
     *  of MED. This description is located by the following link:
     *   http://www.salome-platform.org/salome2/web_med_internet/logiciels/medV2.2.2_doc_html/html/modele_de_donnees.html#3.
     */
    long AddEdge(in long_array IDsOfNodes);

    /*!
     *  Create face, either linear and quadratic (this is determed
     *  by number of given nodes).
     *  \param IdsOfNodes List of node IDs for creation of element.
     *  Needed order of nodes in this list corresponds to description
     *  of MED. This description is located by the following link:
     *   http://www.salome-platform.org/salome2/web_med_internet/logiciels/medV2.2.2_doc_html/html/modele_de_donnees.html#3.
     */
    long AddFace(in long_array IDsOfNodes);

    long AddPolygonalFace(in long_array IdsOfNodes);

    /*!
     *  Create volume, either linear and quadratic (this is determed
     *  by number of given nodes).
     *  \param IdsOfNodes List of node IDs for creation of element.
     *  Needed order of nodes in this list corresponds to description
     *  of MED. This description is located by the following link:
     *   http://www.salome-platform.org/salome2/web_med_internet/logiciels/medV2.2.2_doc_html/html/modele_de_donnees.html#3.
     */
    long AddVolume(in long_array IDsOfNodes);

    /*!
     *  Create volume of many faces, giving nodes for each face.
     *  \param IdsOfNodes List of node IDs for volume creation face by face.
     *  \param Quantities List of integer values, Quantities[i]
     *         gives quantity of nodes in face number i.
     */
    long AddPolyhedralVolume (in long_array IdsOfNodes,
                              in long_array Quantities);

    /*!
     *  Create volume of many faces, giving IDs of existing faces.
     *  \param IdsOfFaces List of face IDs for volume creation.
     *  \note The created volume will refer only to nodes
     *        of the given faces, not to the faces itself.
     */
    long AddPolyhedralVolumeByFaces (in long_array IdsOfFaces);

    boolean MoveNode(in long NodeID, in double x, in double y, in double z);

    boolean InverseDiag(in long NodeID1, in long NodeID2);

    boolean DeleteDiag(in long NodeID1, in long NodeID2);

    boolean Reorient(in long_array IDsOfElements);

    boolean ReorientObject(in SMESH_IDSource theObject);

    /*!
     * \brief Fuse neighbour triangles into quadrangles.
     * \param theElems     The triangles to be fused.
     * \param theCriterion Is used to choose a neighbour to fuse with.
     * \param theMaxAngle  Is a max angle between element normals at which fusion
     *                     is still performed; theMaxAngle is mesured in radians.
     * \return TRUE in case of success, FALSE otherwise.
     */
    boolean TriToQuad (in long_array       IDsOfElements,
		       in NumericalFunctor Criterion,
		       in double           MaxAngle);

    /*!
     * \brief Fuse neighbour triangles into quadrangles.
     *
     * Behaves like the above method, taking list of elements from \a theObject
     */
    boolean TriToQuadObject (in SMESH_IDSource   theObject,
			     in NumericalFunctor Criterion,
			     in double           MaxAngle);

    /*!
     * \brief Split quadrangles into triangles.
     * \param theElems     The faces to be splitted.
     * \param theCriterion Is used to choose a diagonal for splitting.
     * \return TRUE in case of success, FALSE otherwise.
     */
    boolean QuadToTri (in long_array       IDsOfElements,
		       in NumericalFunctor Criterion);

    /*!
     * \brief Split quadrangles into triangles.
     *
     * Behaves like the above method, taking list of elements from \a theObject
     */
    boolean QuadToTriObject (in SMESH_IDSource   theObject,
			     in NumericalFunctor Criterion);

    /*!
     * \brief Split quadrangles into triangles.
     * \param theElems  The faces to be splitted.
     * \param the13Diag Is used to choose a diagonal for splitting.
     * \return TRUE in case of success, FALSE otherwise.
     */
    boolean SplitQuad (in long_array IDsOfElements,
		       in boolean    Diag13);

    /*!
     * \brief Split quadrangles into triangles.
     *
     * Behaves like the above method, taking list of elements from \a theObject
     */
    boolean SplitQuadObject (in SMESH_IDSource theObject,
			     in boolean        Diag13);

    /*!
     *  Find better splitting of the given quadrangle.
     *  \param IDOfQuad  ID of the quadrangle to be splitted.
     *  \param Criterion A criterion to choose a diagonal for splitting.
     *  \return 1 if 1-3 diagonal is better, 2 if 2-4
     *          diagonal is better, 0 if error occurs.
     */
    long BestSplit (in long             IDOfQuad,
		    in NumericalFunctor Criterion);

    enum Smooth_Method { LAPLACIAN_SMOOTH, CENTROIDAL_SMOOTH };

    boolean Smooth(in long_array    IDsOfElements,
                   in long_array    IDsOfFixedNodes,
                   in long          MaxNbOfIterations,
                   in double        MaxAspectRatio,
                   in Smooth_Method Method);

    boolean SmoothObject(in SMESH_IDSource  theObject,
			 in long_array      IDsOfFixedNodes,
			 in long            MaxNbOfIterations,
			 in double          MaxAspectRatio,
			 in Smooth_Method   Method);

    boolean SmoothParametric(in long_array    IDsOfElements,
                             in long_array    IDsOfFixedNodes,
                             in long          MaxNbOfIterations,
                             in double        MaxAspectRatio,
                             in Smooth_Method Method);

    boolean SmoothParametricObject(in SMESH_IDSource  theObject,
                                   in long_array      IDsOfFixedNodes,
                                   in long            MaxNbOfIterations,
                                   in double          MaxAspectRatio,
                                   in Smooth_Method   Method);

    void ConvertToQuadratic(in boolean theForce3d);

    boolean ConvertFromQuadratic();

    void RenumberNodes();

    void RenumberElements();

    void RotationSweep(in long_array       IDsOfElements,
                       in AxisStruct       Axix,
                       in double           AngleInRadians,
                       in long             NbOfSteps,
                       in double           Tolerance);

    void RotationSweepObject(in SMESH_IDSource  theObject,
			     in AxisStruct      Axix,
			     in double          AngleInRadians,
			     in long            NbOfSteps,
			     in double          Tolerance);

    void ExtrusionSweep(in long_array      IDsOfElements,
                        in DirStruct       StepVector,
                        in long            NbOfSteps);

   /*!
    * Generate new elements by extrusion of theElements 
    * by StepVector by NbOfSteps
    * param ExtrFlags set flags for performing extrusion
    * param SewTolerance - uses for comparing locations of nodes if flag
    *   EXTRUSION_FLAG_SEW is set
    */
    void AdvancedExtrusion(in long_array      IDsOfElements,
                           in DirStruct       StepVector,
                           in long            NbOfSteps,
			   in long            ExtrFlags,
			   in double          SewTolerance);

    void ExtrusionSweepObject(in SMESH_IDSource  theObject,
			      in DirStruct       StepVector,
			      in long            NbOfSteps);

    void ExtrusionSweepObject1D(in SMESH_IDSource theObject,
				in DirStruct      StepVector,
				in long           NbOfSteps);

    void ExtrusionSweepObject2D(in SMESH_IDSource theObject,
				in DirStruct      StepVector,
				in long           NbOfSteps);

    enum Extrusion_Error {
      EXTR_OK,
      EXTR_NO_ELEMENTS,
      EXTR_PATH_NOT_EDGE,
      EXTR_BAD_PATH_SHAPE,
      EXTR_BAD_STARTING_NODE,
      EXTR_BAD_ANGLES_NUMBER,
      EXTR_CANT_GET_TANGENT
      };

    Extrusion_Error ExtrusionAlongPath(in long_array        IDsOfElements,
				       in SMESH_Mesh        PathMesh,
				       in GEOM::GEOM_Object PathShape,
				       in long              NodeStart,
				       in boolean           HasAngles,
				       in double_array      Angles,
				       in boolean           HasRefPoint,
				       in PointStruct       RefPoint);

    Extrusion_Error ExtrusionAlongPathObject(in SMESH_IDSource    theObject,
					     in SMESH_Mesh        PathMesh,
					     in GEOM::GEOM_Object PathShape,
					     in long              NodeStart,
					     in boolean           HasAngles,
					     in double_array      Angles,
					     in boolean           HasRefPoint,
					     in PointStruct       RefPoint);

   /*!
    * Compute rotation angles for ExtrusionAlongPath as linear variation
    * of given angles along path steps
    * param PathMesh mesh containing a 1D sub-mesh on the edge, along 
    *                which proceeds the extrusion
    * param PathShape is shape(edge); as the mesh can be complex, the edge 
    *                 is used to define the sub-mesh for the path
    */
    double_array LinearAnglesVariation(in SMESH_Mesh        PathMesh,
                                       in GEOM::GEOM_Object PathShape,
                                       in double_array      Angles);

    enum MirrorType { POINT, AXIS, PLANE };

    void Mirror (in long_array       IDsOfElements,
                 in AxisStruct       Mirror,
                 in MirrorType       theMirrorType,
                 in boolean          Copy);

    void MirrorObject (in SMESH_IDSource  theObject,
		       in AxisStruct      Mirror,
		       in MirrorType      theMirrorType,
		       in boolean         Copy);

    void Translate (in long_array      IDsOfElements,
                    in DirStruct       Vector,
                    in boolean         Copy);

    void TranslateObject (in SMESH_IDSource  theObject,
			  in DirStruct       Vector,
			  in boolean         Copy);

    void Rotate (in long_array       IDsOfElements,
                 in AxisStruct       Axis,
                 in double           AngleInRadians,
                 in boolean          Copy);

    void RotateObject (in SMESH_IDSource  theObject,
		       in AxisStruct      Axis,
		       in double          AngleInRadians,
		       in boolean         Copy);

    void FindCoincidentNodes (in  double              Tolerance,
                              out array_of_long_array GroupsOfNodes);

    void MergeNodes (in array_of_long_array GroupsOfNodes);

    void MergeEqualElements();

    enum Sew_Error {
      SEW_OK,
      SEW_BORDER1_NOT_FOUND,
      SEW_BORDER2_NOT_FOUND,
      SEW_BOTH_BORDERS_NOT_FOUND,
      SEW_BAD_SIDE_NODES,
      SEW_VOLUMES_TO_SPLIT,
      // for SewSideElements() only:
      SEW_DIFF_NB_OF_ELEMENTS,
      SEW_TOPO_DIFF_SETS_OF_ELEMENTS,
      SEW_BAD_SIDE1_NODES,
      SEW_BAD_SIDE2_NODES
      };

    Sew_Error SewFreeBorders (in long FirstNodeID1,
                              in long SecondNodeID1,
                              in long LastNodeID1,
                              in long FirstNodeID2,
                              in long SecondNodeID2,
                              in long LastNodeID2,
			      in boolean CreatePolygons,
			      in boolean CreatePolyedrs);

    Sew_Error SewConformFreeBorders (in long FirstNodeID1,
                                     in long SecondNodeID1,
                                     in long LastNodeID1,
                                     in long FirstNodeID2,
                                     in long SecondNodeID2);

    Sew_Error SewBorderToSide (in long FirstNodeIDOnFreeBorder,
                               in long SecondNodeIDOnFreeBorder,
                               in long LastNodeIDOnFreeBorder,
                               in long FirstNodeIDOnSide,
                               in long LastNodeIDOnSide,
			       in boolean CreatePolygons,
			       in boolean CreatePolyedrs);

    Sew_Error SewSideElements (in long_array IDsOfSide1Elements,
                               in long_array IDsOfSide2Elements,
                               in long       NodeID1OfSide1ToMerge,
                               in long       NodeID1OfSide2ToMerge,
                               in long       NodeID2OfSide1ToMerge,
                               in long       NodeID2OfSide2ToMerge);

   /*!
    * Set new nodes for given element.
    * If number of nodes is not corresponded to type of
    * element - returns false
    */
    boolean ChangeElemNodes(in long ide, in long_array newIDs);

   /*!
    * Return data of mesh edition preview which is computed provided 
    * that the editor was obtained trough SMESH_Mesh::GetMeshEditPreviewer()
    */
    MeshPreviewStruct GetPreviewData();

   /*!
    * If during last operation of MeshEditor some nodes were
    * created this method returns list of it's IDs, if new nodes
    * not creared - returns empty list
    */
    long_array GetLastCreatedNodes();

   /*!
    * If during last operation of MeshEditor some elements were
    * created this method returns list of it's IDs, if new elements
    * not creared - returns empty list
    */
    long_array GetLastCreatedElems();

  };
};

#endif
