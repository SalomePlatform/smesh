//  Copyright (C) 2003  OPEN CASCADE, EADS/CCR, LIP6, CEA/DEN,
//  CEDRAT, EDF R&D, LEG, PRINCIPIA R&D, BUREAU VERITAS 
// 
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public 
//  License as published by the Free Software Foundation; either 
//  version 2.1 of the License. 
// 
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free Software 
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA 
// 
// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
//
//
//
//  File   : SMESH_BasicHypothesis.idl
//  Author : Paul RASCLE, EDF

#ifndef _SMESH_BASICHYPOTHESIS_IDL_
#define _SMESH_BASICHYPOTHESIS_IDL_

#include "SALOME_Exception.idl"
#include "SMESH_Hypothesis.idl"
#include "SMESH_Mesh.idl"


/*!
 * StdMeshers: interfaces to standard hypotheses and algorithms
 */
module StdMeshers
{
  /*!
   * StdMeshers_LocalLength: interface of "Average length" hypothesis
   */
  interface StdMeshers_LocalLength : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets <length> parameter value
     */
    void SetLength(in double length)
      raises (SALOME::SALOME_Exception);

    /*!
     * Sets <precision> parameter value
     *
     * Precision parameter is used to allow rounding a number of segments,
     * calculated from the edge length and average length of segment,
     * to the lower integer, if this value outstands from it in bounds of the precision.
     * Otherwise, the number of segments is rounded to the higher integer.
     * Use value 0.5 to provide rounding to the nearest integer,
     * 1.0 for the lower integer, 0.0 for the higher integer.
     * Default value is 1e-07. In old studies, restored from file,
     * this value will be set to zero, what corresponds to the old behaviour.
     */
    void SetPrecision(in double precision)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <length> parameter value
     */
    double GetLength();

    /*!
     * Returns <precision> parameter value
     */
    double GetPrecision();
  };

  /*!
   * StdMeshers_AutomaticLength: interface of "Automatic length" hypothesis
   */
  interface StdMeshers_AutomaticLength : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets Fineness parameter value
     */
    void SetFineness(in double theFineness)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <Fineness> parameter value
     */
    double GetFineness();
  };

  /*!
   * StdMeshers_NumberOfSegments: interface of "Nb. Segments" hypothesis
   */
  interface StdMeshers_NumberOfSegments : SMESH::SMESH_Hypothesis
  {
    /*!
     * Builds and returns point distribution according to passed density function
     */
    SMESH::double_array BuildDistributionExpr( in string func, in long nbSeg, in long conv )
      raises (SALOME::SALOME_Exception);
    SMESH::double_array BuildDistributionTab( in SMESH::double_array func, in long nbSeg, in long conv )
      raises (SALOME::SALOME_Exception);
  
    /*!
     * Sets <number of segments> parameter value
     */
    void SetNumberOfSegments(in long segmentsNumber)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <number of segments> parameter value
     */
    long GetNumberOfSegments();

    /*!
     * Sets <distribution type> parameter value
     */
    void SetDistrType(in long typ)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <distribution type> parameter value
     */
    long GetDistrType();

    /*!
     * Sets <scale factor> parameter value
     */
    void SetScaleFactor(in double scaleFactor)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <scale factor> parameter value
     */
    double GetScaleFactor()
      raises (SALOME::SALOME_Exception);

    /*!
     * Sets <table function> parameter value for distribution DT_TabFunc
     */
    void SetTableFunction(in SMESH::double_array table)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <table function> parameter value for distribution DT_TabFunc
     */
    SMESH::double_array GetTableFunction()
      raises (SALOME::SALOME_Exception);

    /*!
     * Sets <expression function> parameter value for distribution DT_ExprFunc
     */
    void SetExpressionFunction(in string expr)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <expression function> parameter value for distribution DT_ExprFunc
     */
    string GetExpressionFunction()
      raises (SALOME::SALOME_Exception);

    /*!
     * Sets <conversion mode> parameter value for functional distributions
     */
    void SetConversionMode(in long conv )
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <conversion mode> parameter value for functional distributions
     */
    long ConversionMode()
      raises (SALOME::SALOME_Exception);
  };

  /*!
   * StdMeshers_Arithmetic1D: interface of "Arithmetic 1D" hypothesis
   */
  interface StdMeshers_Arithmetic1D : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets <start segment length> or <end segment length> parameter value
     */
    void SetLength(in double length, in boolean isStartLength) 
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <start segment length> or <end segment length> parameter value
     */
    double GetLength(in boolean isStartLength);
  };

  /*!
   * StdMeshers_MaxElementArea: interface of "Max. Triangle Area" hypothesis
   */
  interface StdMeshers_MaxElementArea : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets <maximum element area> parameter value
     */
    void SetMaxElementArea(in double area) 
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <maximum element area> parameter value
     */
    double GetMaxElementArea();
  };

  /*!
   * StdMeshers_LengthFromEdges: interface of "Length From Edges (2D Hyp. for Triangulator)" hypothesis
   */
  interface StdMeshers_LengthFromEdges : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets <mode> parameter value
     */
    void SetMode(in long mode) 
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <mode> parameter value
     */
    long GetMode();
  };

  /*!
   * StdMeshers_StartEndLength: interface of "Start and End Length" hypothesis
   */
  interface StdMeshers_StartEndLength : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets <start segment length> or <end segment length> parameter value
     */
    void SetLength(in double length, in boolean isStartLength) 
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <start segment length> or <end segment length> parameter value
     */
    double GetLength(in boolean isStartLength);
  };


  /*!
   * StdMeshers_Deflection1D: interface of "Deflection 1D" hypothesis
   */
  interface StdMeshers_Deflection1D : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets <deflection> parameter value
     */
    void SetDeflection(in double deflection)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <deflection> parameter value
     */
    double GetDeflection();
  };


  /*!
   * StdMeshers_MaxElementVolume: interface of "Max. Hexahedron or Tetrahedron Volume" hypothesis
   */
  interface StdMeshers_MaxElementVolume : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets <maximum element volume> parameter value
     */
    void SetMaxElementVolume(in double volume) 
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <maximum element volume> parameter value
     */
    double GetMaxElementVolume();
  };

  /*!
   * StdMeshers_NotConformAllowed: interface of "Not Conform Mesh Allowed" hypothesis.
   * Presence of this hypothesis permits to algorithm generation of not conform mesh.
   */
  interface StdMeshers_NotConformAllowed : SMESH::SMESH_Hypothesis
  {
  };

  /*!
   * StdMeshers_Propagation: interface of "Propagation" hypothesis.
   * Presence of this hypothesis on any edge propagates any other 1D
   * hypothesis from this edge on all edges, opposite to it.
   * It concerns only edges of quadrangle faces.
   */
  interface StdMeshers_Propagation : SMESH::SMESH_Hypothesis
  {
  };

  /*!
   * StdMeshers_QuadranglePreference: interface of "QuadranglePreference" hypothesis.
   * This hypothesis is used by StdMeshers_Quadrangle_2D algorithm.
   * Presence of this hypothesis forces construction of quadrangles if the number
   * of nodes on opposite edges is not the same in the case where the global number
   * of nodes on edges is even
   */
  interface StdMeshers_QuadranglePreference : SMESH::SMESH_Hypothesis
  {
  };

  /*!
   * StdMeshers_QuadraticMesh: interface of "QuadraticMesh" hypothesis.
   * This is an auxiliary 1D hypothesis whose presence forces construction 
   * of quadratic edges.
   * If the 2D mesher sees that all boundary edges are quadratic ones,
   * it generates quadratic faces, else it generates linear faces using
   * medium nodes as if they were vertex ones.
   * The 3D mesher generates quadratic volumes only if all boundary faces
   * are quadratic ones, else it fails.
   */
  interface StdMeshers_QuadraticMesh : SMESH::SMESH_Hypothesis
  {
  };


  /*!
   * StdMeshers_NumberOfLayers: interface of "Nb. Layers" hypothesis.
   * This hypothesis is used by "Radial prism" algorithm.
   * It specifies number of segments between the internal 
   * and the external surfaces.
   */
  interface StdMeshers_NumberOfLayers : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets <number of segments> parameter value
     */
    void SetNumberOfLayers(in long numberOfLayers) 
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <number of layers> parameter value
     */
    long GetNumberOfLayers();

  };

  /*!
   * StdMeshers_LayerDistribution: interface of "Distribution of Layers" hypothesis.
   * This hypothesis is used by "Radial prism" algorithm.
   * It specifies 1D hypothesis defining distribution of segments between the internal 
   * and the external surfaces.
   */
  interface StdMeshers_LayerDistribution : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets  1D hypothesis specifying distribution of layers
     */
    void SetLayerDistribution(in SMESH::SMESH_Hypothesis distributionHyp) 
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns 1D hypothesis specifying distribution of layers
     */
    SMESH::SMESH_Hypothesis GetLayerDistribution();

  };

  /*!
   * interface of "ProjectionSource1D" hypothesis.
   * This hypothesis specifies a meshed edge to take a mesh pattern from
   * and optionally association of vertices between the source edge and a
   * target one (where a hipothesis is assigned to)
   */
  interface StdMeshers_ProjectionSource1D : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets source <edge> to take a mesh pattern from
     */
    void SetSourceEdge(in GEOM::GEOM_Object edge)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns the source edge
     */
    GEOM::GEOM_Object GetSourceEdge();

    /*!
     * Sets source <mesh> to take a mesh pattern from
     */
    void SetSourceMesh(in SMESH::SMESH_Mesh mesh);

    /*!
     * Return source mesh
     */
    SMESH::SMESH_Mesh GetSourceMesh();

    /*!
     * Sets vertex association between the source edge and the target one.
     * This parameter is optional
     */
    void SetVertexAssociation(in GEOM::GEOM_Object sourceVertex,
                              in GEOM::GEOM_Object targetVertex)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns the vertex associated with the target vertex.
     * Result may be nil if association not set
     */
    GEOM::GEOM_Object  GetSourceVertex();

    /*!
     * Returns the vertex associated with the source vertex.
     * Result may be nil if association not set
     */
    GEOM::GEOM_Object  GetTargetVertex();
  };

  /*!
   * interface of "ProjectionSource2D" hypothesis.
   * This hypothesis specifies a meshed face to take a mesh pattern from
   * and optionally association of vertices between the source face and a
   * target one (where a hipothesis is assigned to)
   */
  interface StdMeshers_ProjectionSource2D : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets a source <face> to take a mesh pattern from
     */
    void SetSourceFace(in GEOM::GEOM_Object face)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns the source face
     */
    GEOM::GEOM_Object GetSourceFace();

    /*!
     * Sets source <mesh> to take a mesh pattern from
     */
    void SetSourceMesh(in SMESH::SMESH_Mesh mesh);

    /*!
     * Return source mesh
     */
    SMESH::SMESH_Mesh GetSourceMesh();

    /*!
     * Sets vertex association between the source face and the target one.
     * This parameter is optional.
     * Two vertices must belong to one edge of a face
     */
    void SetVertexAssociation(in GEOM::GEOM_Object sourceVertex1,
                              in GEOM::GEOM_Object sourceVertex2,
                              in GEOM::GEOM_Object targetVertex1,
                              in GEOM::GEOM_Object targetVertex2)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns the <i>-th source vertex associated with the <i>-th target vertex.
     * Result may be nil if association not set.
     * Valid indices are 1 and 2
     */
    GEOM::GEOM_Object  GetSourceVertex(in long i)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns the <i>-th target vertex associated with the <i>-th source vertex.
     * Result may be nil if association not set.
     * Valid indices are 1 and 2
     */
    GEOM::GEOM_Object  GetTargetVertex(in long i)
      raises (SALOME::SALOME_Exception);
  };

  /*!
   * interface of "ProjectionSource3D" hypothesis.
   * This hypothesis specifies a meshed shell or solid to take a mesh pattern from
   * and optionally association of vertices between the source shape and a
   * target one (where a hipothesis is assigned to)
   */
  interface StdMeshers_ProjectionSource3D : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets a source <shape> to take a mesh pattern from
     */
    void SetSource3DShape(in GEOM::GEOM_Object shape)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns the source shape
     */
    GEOM::GEOM_Object GetSource3DShape();

    /*!
     * Sets source <mesh> to take a mesh pattern from
     */
    void SetSourceMesh(in SMESH::SMESH_Mesh mesh);

    /*!
     * Return source mesh
     */
    SMESH::SMESH_Mesh GetSourceMesh();

    /*!
     * Sets vertex association between the source shape and the target one.
     * This parameter is optional.
     * Two vertices must belong to one edge of a shape
     */
    void SetVertexAssociation(in GEOM::GEOM_Object sourceVertex1,
                              in GEOM::GEOM_Object sourceVertex2,
                              in GEOM::GEOM_Object targetVertex1,
                              in GEOM::GEOM_Object targetVertex2)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns the <i>-th source vertex associated with the <i>-th target vertex.
     * Result may be nil if association not set.
     * Valid indices are 1 and 2
     */
    GEOM::GEOM_Object  GetSourceVertex(in long i)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns the <i>-th target vertex associated with the <i>-th source vertex.
     * Result may be nil if association not set.
     * Valid indices are 1 and 2
     */
    GEOM::GEOM_Object  GetTargetVertex(in long i)
      raises (SALOME::SALOME_Exception);
  };

  /*!
   * interface of "SegmentLengthAroundVertex" hypothesis.
   * This hypothesis specifies length of segments adjacent to the vertex the
   * hypothesis is assigned to
   */
  interface StdMeshers_SegmentLengthAroundVertex : SMESH::SMESH_Hypothesis
  {
    /*!
     * Sets <length> parameter value
     */
    void SetLength(in double length)
      raises (SALOME::SALOME_Exception);

    /*!
     * Returns <length> parameter value
     */
    double GetLength();
  };

  /*!
   * StdMeshers_SegmentAroundVertex_0D: interface of "SegmentAroundVertex" algorithm
   */
  interface StdMeshers_SegmentAroundVertex_0D : SMESH::SMESH_0D_Algo
  {
  };

  /*!
   * StdMeshers_Regular_1D: interface of "Wire discretisation" algorithm
   */
  interface StdMeshers_Regular_1D : SMESH::SMESH_1D_Algo
  {
  };

  /*!
   * StdMeshers_CompositeSegment_1D: interface of "Composite side discretisation" algorithm
   */
  interface StdMeshers_CompositeSegment_1D : SMESH::SMESH_1D_Algo
  {
  };

  /*!
   * StdMeshers_MEFISTO_2D: interface of "Triangle (Mefisto)" algorithm
   */
  interface StdMeshers_MEFISTO_2D : SMESH::SMESH_2D_Algo
  {
  };

  /*!
   * StdMeshers_Quadrangle_2D: interface of "Quadrangle (Mapping)" algorithm
   */
  interface StdMeshers_Quadrangle_2D : SMESH::SMESH_2D_Algo
  {
  };

  /*!
   * StdMeshers_Hexa_3D: interface of "Hexahedron (i,j,k)" algorithm
   */
  interface StdMeshers_Hexa_3D : SMESH::SMESH_3D_Algo
  {
  };

  /*!
   * StdMeshers_Prism_3D: interface of "3D extrusion" algorithm
   */
  interface StdMeshers_Prism_3D : SMESH::SMESH_3D_Algo
  {
  };

  /*!
   * StdMeshers_RadialPrism_3D: interface of "Radial Prism" algorithm
   */
  interface StdMeshers_RadialPrism_3D : SMESH::SMESH_3D_Algo
  {
  };

  /*!
   * StdMeshers_Projection_3D: interface of "Projection 3D" algorithm
   */
  interface StdMeshers_Projection_3D : SMESH::SMESH_3D_Algo
  {
  };

  /*!
   * StdMeshers_Projection_2D: interface of "Projection 2D" algorithm
   */
  interface StdMeshers_Projection_2D : SMESH::SMESH_2D_Algo
  {
  };

  /*!
   * StdMeshers_Projection_1D: interface of "Projection 1D" algorithm
   */
  interface StdMeshers_Projection_1D : SMESH::SMESH_1D_Algo
  {
  };

  /*!
   * StdMeshers_UseExisting_2D: interface of "UseExisting 2D" algorithm
   * doing nothing to allow mesh generation by mesh edition functions in TUI mode
   */
  interface StdMeshers_UseExisting_2D : SMESH::SMESH_2D_Algo
  {
  };

  /*!
   * StdMeshers_UseExisting_1D: interface of "UseExisting 1D" algorithm
   * doing nothing to allow mesh generation by mesh edition functions in TUI mode
   */
  interface StdMeshers_UseExisting_1D : SMESH::SMESH_1D_Algo
  {
  };

};

#endif
