/*!

\page tui_defining_hypotheses_page Defining Hypotheses and Algorithms

<h2>Defining 1D Hypotheses</h2>

<br>
\anchor tui_1d_arithmetic
<h3>1D Arithmetic</h3>

\code
import geompy
import smesh

# create a box
box = geompy.MakeBoxDXDYDZ(10., 10., 10.)
geompy.addToStudy(box, "Box")

# create a hexahedral mesh on the box
hexa = smesh.Mesh(box, "Box : hexahedrical mesh")

# create a Regular 1D algorithm for edges
algo1D = hexa.Segment()

# optionally reverse node distribution on certain edges
allEdges = geompy.SubShapeAllSortedIDs( box, geompy.ShapeType["EDGE"])
reversedEdges = [ allEdges[0], allEdges[4] ]

# define "Arithmetic1D" hypothesis to cut all edges in several segments with increasing arithmetic length 
algo1D.Arithmetic1D(1, 4, reversedEdges)

# create a quadrangle 2D algorithm for faces
hexa.Quadrangle()

# create a hexahedron 3D algorithm for solids
hexa.Hexahedron()

# compute the mesh
hexa.Compute()
\endcode

<br>
\anchor tui_deflection_1d
<h3>Deflection 1D and Number of Segments</h3>

\code
import geompy
import smesh

# create a face from arc and straight segment
px = geompy.MakeVertex(100., 0.  , 0.  )
py = geompy.MakeVertex(0.  , 100., 0.  )
pz = geompy.MakeVertex(0.  , 0.  , 100.)

exy = geompy.MakeEdge(px, py)
arc = geompy.MakeArc(py, pz, px)

wire = geompy.MakeWire([exy, arc])

isPlanarFace = 1
face1 = geompy.MakeFace(wire, isPlanarFace)
geompy.addToStudy(face1,"Face1")

# get edges from the face
e_straight,e_arc = geompy.SubShapeAll(face1, geompy.ShapeType["EDGE"])
geompy.addToStudyInFather(face1, e_arc, "Arc Edge")

# create hexahedral mesh
hexa = smesh.Mesh(face1, "Face : triangle mesh")

# define "NumberOfSegments" hypothesis to cut a straight edge in a fixed number of segments
algo1D = hexa.Segment()
algo1D.NumberOfSegments(6)

# define "MaxElementArea" hypothesis
algo2D = hexa.Triangle()
algo2D.MaxElementArea(70.0)

# define a local "Deflection1D" hypothesis on the arc
algo_local = hexa.Segment(e_arc)
algo_local.Deflection1D(1.0)

# compute the mesh
hexa.Compute()
\endcode

<br>
\anchor tui_start_and_end_length
<h3>Start and End Length</h3>

\code
from geompy import *
import smesh

# create a box
box = MakeBoxDXDYDZ(10., 10., 10.)
addToStudy(box, "Box")

# get one edge of the box to put local hypothesis on
p5 = MakeVertex(5., 0., 0.)
EdgeX = GetEdgeNearPoint(box, p5)
addToStudyInFather(box, EdgeX, "Edge [0,0,0 - 10,0,0]")

# create a hexahedral mesh on the box
hexa = smesh.Mesh(box, "Box : hexahedrical mesh")

# set algorithms
algo1D = hexa.Segment()
hexa.Quadrangle()
hexa.Hexahedron()

# define "NumberOfSegments" hypothesis to cut an edge in a fixed number of segments
algo1D.NumberOfSegments(4)

# create a local hypothesis
algo_local = hexa.Segment(EdgeX)

# define "StartEndLength" hypothesis to cut an edge in several segments with increasing geometric length
algo_local.StartEndLength(1, 6)

# define "Propagation" hypothesis that propagates all other hypothesis
# on all edges on the opposite side in case of quadrangular faces
algo_local.Propagation()

# compute the mesh
hexa.Compute()
\endcode

<br>
\anchor tui_average_length
<h3>Average Length</h3>

\code
from geompy import *
import smesh

# create a box
box = MakeBoxDXDYDZ(10., 10., 10.)
addToStudy(box, "Box")

# get one edge of the box to put local hypothesis on
p5 = MakeVertex(5., 0., 0.)
EdgeX = GetEdgeNearPoint(box, p5)
addToStudyInFather(box, EdgeX, "Edge [0,0,0 - 10,0,0]")

# create a hexahedral mesh on the box
hexa = smesh.Mesh(box, "Box : hexahedrical mesh")

# set algorithms
algo1D = hexa.Segment()
hexa.Quadrangle()
hexa.Hexahedron()

# define "NumberOfSegments" hypothesis to cut all edges in a fixed number of segments
algo1D.NumberOfSegments(4)

# create a sub-mesh
algo_local = hexa.Segment(EdgeX)

# define "LocalLength" hypothesis to cut an edge in several segments with the same length
algo_local.LocalLength(2.)

# define "Propagation" hypothesis that propagates all other hypothesis
# on all edges on the opposite side in case of quadrangular faces
algo_local.Propagation()

# compute the mesh
hexa.Compute()
\endcode

<br><h2>Defining 2D and 3D hypotheses</h2>

<br>
\anchor tui_max_element_area
<h3>Maximum Element Area</h3>

\code
import geompy
import smesh
import salome 

# create a face
px   = geompy.MakeVertex(100., 0.  , 0.  )
py   = geompy.MakeVertex(0.  , 100., 0.  )
pz   = geompy.MakeVertex(0.  , 0.  , 100.)

vxy = geompy.MakeVector(px, py)
arc = geompy.MakeArc(py, pz, px)
wire = geompy.MakeWire([vxy, arc])

isPlanarFace = 1
face = geompy.MakeFace(wire, isPlanarFace)

# add the face in the study
id_face = geompy.addToStudy(face, "Face to be meshed")

# create a mesh
tria_mesh = smesh.Mesh(face, "Face : triangulation")

# define 1D meshing:
algo = tria_mesh.Segment()
algo.NumberOfSegments(20)

# define 2D meshing:

# assign triangulation algorithm
algo = tria_mesh.Triangle()

# apply "Max Element Area" hypothesis to each triangle
algo.MaxElementArea(100)

# compute the mesh
tria_mesh.Compute()
\endcode

<br>
\anchor tui_max_element_volume
<h3>Maximum Element Volume</h3>

\code
import geompy
import smesh

# create a cylinder
cyl = geompy.MakeCylinderRH(30., 50.)
geompy.addToStudy(cyl, "cyl")

# create a mesh on the cylinder
tetra = smesh.Mesh(cyl, "Cylinder : tetrahedrical mesh")

# assign algorithms
algo1D = tetra.Segment()
algo2D = tetra.Triangle()
algo3D = tetra.Tetrahedron(smesh.NETGEN)

# assign 1D and 2D hypotheses
algo1D.NumberOfSegments(7)
algo2D.MaxElementArea(150.)

# assign Max Element Volume hypothesis
algo3D.MaxElementVolume(200.)

# compute the mesh
ret = tetra.Compute()
if ret == 0:
    print "probleme when computing the mesh"
else:
    print "Computation succeded"
\endcode

<br>
\anchor tui_length_from_edges
<h3>Length from Edges</h3>

\code
import geompy
import smesh

# create sketchers
sketcher1 = geompy.MakeSketcher("Sketcher:F 0 0:TT 70 0:TT 70 70:TT 0 70:WW")
sketcher2 = geompy.MakeSketcher("Sketcher:F 20 20:TT 50 20:TT 50 50:TT 20 50:WW")

# create a face from two wires
isPlanarFace = 1
face1 = geompy.MakeFaces([sketcher1, sketcher2], isPlanarFace)
geompy.addToStudy(face1, "Face1")

# create a mesh
tria = smesh.Mesh(face1, "Face : triangle 2D mesh")

# Define 1D meshing
algo1D = tria.Segment()
algo1D.NumberOfSegments(2)

# create and assign the algorithm for 2D meshing with triangles
algo2D = tria.Triangle()

# create and assign "LengthFromEdges" hypothesis to build triangles based on the length of the edges taken from the wire
algo2D.LengthFromEdges()

# compute the mesh
tria.Compute()
\endcode

<br><h2>Defining Additional Hypotheses</h2>

<br>
\anchor tui_propagation
<h3>Propagation</h3>

\code
from geompy import *
import smesh

# create a box
box = MakeBoxDXDYDZ(10., 10., 10.)
addToStudy(box, "Box")

# get one edge of the box to put local hypothesis on
p5 = MakeVertex(5., 0., 0.)
EdgeX = GetEdgeNearPoint(box, p5)
addToStudyInFather(box, EdgeX, "Edge [0,0,0 - 10,0,0]")

# create a hexahedral mesh on the box
hexa = smesh.Mesh(box, "Box : hexahedrical mesh")

# set global algorithms and hypotheses
algo1D = hexa.Segment()
hexa.Quadrangle()
hexa.Hexahedron()
algo1D.NumberOfSegments(4)

# create a sub-mesh with local 1D hypothesis and propagation
algo_local = hexa.Segment(EdgeX)

# define "Arithmetic1D" hypothesis to cut an edge in several segments with increasing length
algo_local.Arithmetic1D(1, 4)

# define "Propagation" hypothesis that propagates all other 1D hypotheses
# from all edges on the opposite side of a face in case of quadrangular faces
algo_local.Propagation()

# compute the mesh
hexa.Compute()
\endcode

<br>
\anchor tui_defining_meshing_algos
<h2>Defining Meshing Algorithms</h2>

\code
import geompy
import smesh

# create a box
box = geompy.MakeBoxDXDYDZ(10., 10., 10.)
geompy.addToStudy(box, "Box")

# 1. Create a hexahedral mesh on the box
hexa = smesh.Mesh(box, "Box : hexahedrical mesh")

# create a Regular 1D algorithm for edges
algo1D = hexa.Segment()

# create a quadrangle 2D algorithm for faces
algo2D = hexa.Quadrangle()

# create a hexahedron 3D algorithm for solids
algo3D = hexa.Hexahedron()

# define hypotheses
algo1D.Arithmetic1D(1, 4)

# compute the mesh
hexa.Compute()

# 2. Create a tetrahedral mesh on the box
tetra = smesh.Mesh(box, "Box : tetrahedrical mesh")

# create a Regular 1D algorithm for edges
algo1D = tetra.Segment()

# create a Mefisto 2D algorithm for faces
algo2D = tetra.Triangle()

# create a Netgen 3D algorithm for solids
algo3D = tetra.Tetrahedron(smesh.NETGEN)

# define hypotheses
algo1D.Arithmetic1D(1, 4)
algo2D.LengthFromEdges()

# compute the mesh
tetra.Compute()

# 3. Create a tetrahedral mesh on the box with NETGEN_2D3D algorithm
tetraN = smesh.Mesh(box, "Box : tetrahedrical mesh by NETGEN_2D3D")

# create a Netgen_2D3D algorithm for solids
algo3D = tetraN.Tetrahedron(smesh.FULL_NETGEN) 

# define hypotheses
n23_params = algo3D.Parameters()

# compute the mesh
tetraN.Compute()
\endcode

\n Other meshing algorithms:

<ul>
<li>\subpage tui_defining_blsurf_hypotheses_page</li>
</ul>
*/