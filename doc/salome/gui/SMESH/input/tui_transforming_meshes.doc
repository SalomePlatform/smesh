/*!

\page tui_transforming_meshes_page Transforming Meshes

<br><h2>Transforming Meshes</h2>

<br>
\anchor tui_translation
<h3>Translation</h3>

\code
import SMESH_mechanic

smesh = SMESH_mechanic.smesh 
mesh = SMESH_mechanic.mesh 

# define translation vector
point = smesh.PointStruct(-150., -150., 0.)
vector =smesh.DirStruct(point) 

# translate a mesh
doCopy = 1

mesh.Translate([], vector, doCopy)
\endcode

<br>
\anchor tui_rotation
<h3>Rotation</h3>

\code
import math

import SMESH_mechanic

smesh = SMESH_mechanic.smesh
mesh = SMESH_mechanic.mesh 

# define rotation axis and angle
axisXYZ = smesh.AxisStruct(0., 0., 0., 5., 5., 20.)
angle270 = 1.5 * math.pi

# rotate a mesh
mesh.Rotate([], axisXYZ, angle270, 1)  
\endcode

<br>
\anchor tui_scale
<h3>Scale</h3>

\code
import geompy
Box = geompy.MakeBoxDXDYDZ(200, 200, 200)
f = geompy.SubShapeAllSorted(Box, geompy.ShapeType["FACE"])

import smesh,SMESH
import StdMeshers
Mesh1 = smesh.Mesh(f[0])
Regular_1D = Mesh1.Segment()
Nb_Segments_1 = Regular_1D.NumberOfSegments(3)
Nb_Segments_1.SetDistrType( 0 )
Quadrangle_2D = Mesh1.Quadrangle()
isDone = Mesh1.Compute()

#Perform scale opration for whole mesh with creation of new mesh
newMesh = Mesh1.ScaleMakeMesh(Mesh1,SMESH.PointStruct(100,100,200),[0.5,0.3,0.7],True,"ScaledMesh")

#Perform scale operation for whole mesh with copy of elements
Mesh1.Scale(Mesh1,SMESH.PointStruct(200,100,100),[0.5,0.5,0.5],True,True)

#Perform scale opration for two edges with moving of elements
Mesh1.Scale([1,2],SMESH.PointStruct(-100,100,100),[0.8,1.0,0.7],False)

#Perform scale opration for one face with moving of elements
Mesh1.Scale([21],SMESH.PointStruct(0,200,200),[0.7,0.7,0.7],False)
\endcode

<br>
\anchor tui_symmetry
<h3>Symmetry</h3>

\code
import math

import SMESH_mechanic

smesh = SMESH_mechanic.smesh
mesh = SMESH_mechanic.mesh 

# create a symmetrical copy of the mesh mirrored through a point
axis = SMESH.AxisStruct(0, 0, 0, 0, 0, 0)

mesh.Mirror([], axis, smesh.POINT, 1)
\endcode

<br>
\anchor tui_merging_nodes
<h3>Merging Nodes</h3>

\code
import SMESH_mechanic
mesh = SMESH_mechanic.mesh

# merge nodes
Tolerance = 25.0

GroupsOfNodes =  mesh.FindCoincidentNodes(Tolerance)
mesh.MergeNodes(GroupsOfNodes)  
\endcode

<br>
\anchor tui_merging_elements
<h3>Merging Elements</h3>

\code
import salome
import geompy
import smesh

# create a face to be meshed
px = geompy.MakeVertex(100., 0.  , 0.  )
py = geompy.MakeVertex(0.  , 100., 0.  )
pz = geompy.MakeVertex(0.  , 0.  , 100.)

vxy = geompy.MakeVector(px, py)
arc = geompy.MakeArc(py, pz, px)

wire = geompy.MakeWire([vxy, arc])
isPlanarFace = 1

face1 = geompy.MakeFace(wire, isPlanarFace)
id_face1 = geompy.addToStudy(face1, "Face1")

# create a circle to be an extrusion path
px1 = geompy.MakeVertex( 100.,  100.,  0.)
py1 = geompy.MakeVertex(-100., -100.,  0.)
pz1 = geompy.MakeVertex(   0.,    0., 50.)

circle = geompy.MakeCircleThreePnt(py1, pz1, px1)
id_circle = geompy.addToStudy(circle, "Path")
 
# create a 2D mesh on the face
trias = smesh.Mesh(face1, "Face : 2D mesh")

algo1D = trias.Segment()
algo1D.NumberOfSegments(6)
algo2D = trias.Triangle()
algo2D.LengthFromEdges()

trias.Compute()

# create a path mesh
circlemesh = smesh.Mesh(circle, "Path mesh")
algo = circlemesh.Segment()
algo.NumberOfSegments(10)
circlemesh.Compute()

# extrusion of the mesh
trias.ExtrusionAlongPath([], circlemesh, circle,
                         1, 0, [], 0, smesh.PointStruct(0, 0, 0))

# merge nodes
print "Number of nodes before MergeNodes:", 
trias.NbNodes()
tolerance = 0.001
array_of_nodes_groups = trias.FindCoincidentNodes(tolerance)

trias.MergeNodes(array_of_nodes_groups)

print "Number of nodes after MergeNodes:", trias.NbNodes()
print ""
print "Number of elements before MergeEqualElements:"
print "Edges      : ", trias.NbEdges()
print "Triangles  : ", trias.NbTriangles()
print "Quadrangles: ", trias.NbQuadrangles()
print "Volumes    : ", trias.NbVolumes()

# merge elements
trias.MergeEqualElements()
print "Number of elements after MergeEqualElements:"
print "Edges      : ", trias.NbEdges()
print "Triangles  : ", trias.NbTriangles()
print "Quadrangles: ", trias.NbQuadrangles()
print "Volumes    : ", trias.NbVolumes()

salome.sg.updateObjBrowser(1)
\endcode

<br><h2>Sewing Meshes</h2>

<br>
\anchor tui_sew_meshes_border_to_side
<h3>Sew Meshes Border to Side</h3>

\code
import geompy
import smesh

# create two faces of a box
box1 = geompy.MakeBox(0., 0., -10., 30., 20., 25.)
facesList1 = geompy.SubShapeAll(box1, geompy.ShapeType["FACE"])
face1 = facesList1[2]

box2 = geompy.MakeBox(0., 5., 0., 20., 20., 15.)
facesList2 = geompy.SubShapeAll(box2, geompy.ShapeType["FACE"])
face2 = facesList2[1]

edgesList = geompy.SubShapeAll(face2, geompy.ShapeType["EDGE"])
edge1 = edgesList[2]

aComp = geompy.MakeCompound([face1, face2])
geompy.addToStudy(aComp, "Two faces")

# create a mesh on two faces
mesh = smesh.Mesh(aComp, "Two faces : quadrangle mesh")

algo1D = mesh.Segment()
algo1D.NumberOfSegments(9)
algo2D = mesh.Quadrangle()

algo_local = mesh.Segment(edge1)
algo_local.Arithmetic1D(1, 4)
algo_local.Propagation()

mesh.Compute()

# sew border to side
# FirstNodeIDOnFreeBorder, SecondNodeIDOnFreeBorder, LastNodeIDOnFreeBorder,
# FirstNodeIDOnSide, LastNodeIDOnSide,
# CreatePolygons, CreatePolyedrs
mesh.SewBorderToSide(5, 45, 6, 113, 109, 0, 0)
\endcode

<br>
\anchor tui_sew_conform_free_borders
<h3>Sew Conform Free Borders</h3>

\code
import geompy
import smesh

# create two faces of the box
box1 = geompy.MakeBox(0., 0., -10., 20., 20., 15.)
facesList1 = geompy.SubShapeAll(box1, geompy.ShapeType["FACE"])
face1 = facesList1[2]

box2 = geompy.MakeBox(0., 5., 0., 20., 20., 15.)
facesList2 = geompy.SubShapeAll(box2, geompy.ShapeType["FACE"])
face2 = facesList2[1]

edgesList = geompy.SubShapeAll(face2, geompy.ShapeType["EDGE"])
edge1 = edgesList[2]

aComp = geompy.MakeCompound([face1, face2])
geompy.addToStudy(aComp, "Two faces")

# create a mesh on two faces
mesh = smesh.Mesh(aComp, "Two faces : quadrangle mesh")

algo1D = mesh.Segment()
algo1D.NumberOfSegments(9)
algo2D = mesh.Quadrangle()

algo_local = mesh.Segment(edge1)
algo_local.Arithmetic1D(1, 4)
algo_local.Propagation()

mesh.Compute()

# sew conform free borders
# FirstNodeID1, SecondNodeID1, LastNodeID1, FirstNodeID2, SecondNodeID2
mesh.SewConformFreeBorders(5, 45, 6, 3, 24) 
\endcode

<br>
\anchor tui_sew_free_borders
<h3>Sew Free Borders</h3>

\code
import geompy
import smesh

# create two faces of the box
box1 = geompy.MakeBox(0., 0., 0., 20., 20., 15.)
facesList1 = geompy.SubShapeAll(box1, geompy.ShapeType["FACE"])
face1 = facesList1[2]

box2 = geompy.MakeBox(0., 5., 0., 20., 20., 15.)
facesList2 = geompy.SubShapeAll(box2, geompy.ShapeType["FACE"])
face2 = facesList2[1]

edgesList = geompy.SubShapeAll(face2, geompy.ShapeType["EDGE"])
edge1 = edgesList[2]

aComp = geompy.MakeCompound([face1, face2])
geompy.addToStudy(aComp, "Two faces")

# create a mesh on two faces
mesh = smesh.Mesh(aComp, "Two faces : quadrangle mesh")

algo1D = mesh.Segment()
algo1D.NumberOfSegments(4)
algo2D = mesh.Quadrangle()

algo_local = mesh.Segment(edge1)
algo_local.Arithmetic1D(1, 4)
algo_local.Propagation()

mesh.Compute()

# sew free borders
# FirstNodeID1, SecondNodeID1, LastNodeID1,
# FirstNodeID2, SecondNodeID2, LastNodeID2, CreatePolygons, CreatePolyedrs
mesh.SewFreeBorders(6, 21, 5, 1, 12, 3, 0, 0)
\endcode

<br>
\anchor tui_sew_side_elements
<h3>Sew Side Elements</h3>

\code
import geompy
import smesh

# create two boxes
box1 = geompy.MakeBox(0.,  0., 0., 10., 10., 10.)
box2 = geompy.MakeBox(0., 15., 0., 20., 25., 10.)

EdgesList = geompy.SubShapeAll(box2, geompy.ShapeType["EDGE"])

aComp = geompy.MakeCompound([box1, box2])
geompy.addToStudy(aComp, "Two boxes")

# create a mesh on two boxes
mesh = smesh.Mesh(aComp, "Two faces : quadrangle mesh")

algo1D = mesh.Segment()
algo1D.NumberOfSegments(2)
algo2D = mesh.Quadrangle()

algo_local = mesh.Segment(EdgesList[8])
algo_local.NumberOfSegments(4)
algo_local.Propagation()

mesh.Compute()

# sew side elements
# IDsOfSide1Elements, IDsOfSide2Elements,
# NodeID1OfSide1ToMerge, NodeID1OfSide2ToMerge, NodeID2OfSide1ToMerge, NodeID2OfSide2ToMerge
mesh.SewSideElements([69, 70, 71, 72], [91, 92, 89, 90], 8, 38, 23, 58)
\endcode

*/
