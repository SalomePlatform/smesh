/*!

\page tui_transforming_meshes_page Transforming Meshes

<br><h2>Transforming Meshes</h2>

<br>
\anchor tui_translation
<h3>Translation</h3>

\code
import SMESH_mechanic

smesh = SMESH_mechanic.smesh 
mesh = SMESH_mechanic.mesh 

# define translation vector
point = smesh.PointStruct(-150., -150., 0.)
vector =smesh.DirStruct(point) 

# translate a mesh
doCopy = 1

mesh.Translate([], vector, doCopy)
\endcode

<br>
\anchor tui_rotation
<h3>Rotation</h3>

\code
import math

import SMESH_mechanic

smesh = SMESH_mechanic.smesh
mesh = SMESH_mechanic.mesh 

# define rotation axis and angle
axisXYZ = smesh.AxisStruct(0., 0., 0., 5., 5., 20.)
angle270 = 1.5 * math.pi

# rotate a mesh
mesh.Rotate([], axisXYZ, angle270, 1)  
\endcode

<br>
\anchor tui_scale
<h3>Scale</h3>

\code
import geompy
Box = geompy.MakeBoxDXDYDZ(200, 200, 200)
f = geompy.SubShapeAllSorted(Box, geompy.ShapeType["FACE"])

import smesh,SMESH
import StdMeshers
Mesh1 = smesh.Mesh(f[0])
Regular_1D = Mesh1.Segment()
Nb_Segments_1 = Regular_1D.NumberOfSegments(3)
Nb_Segments_1.SetDistrType( 0 )
Quadrangle_2D = Mesh1.Quadrangle()
isDone = Mesh1.Compute()

#Perform scale opration for the whole mesh and creation of a new mesh
newMesh = Mesh1.ScaleMakeMesh(Mesh1,SMESH.PointStruct(100,100,200),[0.5,0.3,0.7],True,"ScaledMesh")

#Perform scale operation for the whole mesh and copy elements
Mesh1.Scale(Mesh1,SMESH.PointStruct(200,100,100),[0.5,0.5,0.5],True,True)

#Perform scale opration for two edges and move elements
Mesh1.Scale([1,2],SMESH.PointStruct(-100,100,100),[0.8,1.0,0.7],False)

#Perform scale opration for one face and move elements
Mesh1.Scale([21],SMESH.PointStruct(0,200,200),[0.7,0.7,0.7],False)
\endcode

<br>
\anchor tui_symmetry
<h3>Symmetry</h3>

\code
import math

import SMESH_mechanic

smesh = SMESH_mechanic.smesh
mesh = SMESH_mechanic.mesh 

# create a symmetrical copy of the mesh mirrored through a point
axis = SMESH.AxisStruct(0, 0, 0, 0, 0, 0)

mesh.Mirror([], axis, smesh.POINT, 1)
\endcode

<br>
\anchor tui_merging_nodes
<h3>Merging Nodes</h3>

\code
import SMESH_mechanic
mesh = SMESH_mechanic.mesh

# merge nodes
Tolerance = 25.0

GroupsOfNodes =  mesh.FindCoincidentNodes(Tolerance)
mesh.MergeNodes(GroupsOfNodes)  
\endcode

<br>
\anchor tui_merging_elements
<h3>Merging Elements</h3>

\code
import salome
import geompy
import smesh

# create a face to be meshed
px = geompy.MakeVertex(100., 0.  , 0.  )
py = geompy.MakeVertex(0.  , 100., 0.  )
pz = geompy.MakeVertex(0.  , 0.  , 100.)

vxy = geompy.MakeVector(px, py)
arc = geompy.MakeArc(py, pz, px)

wire = geompy.MakeWire([vxy, arc])
isPlanarFace = 1

face1 = geompy.MakeFace(wire, isPlanarFace)
id_face1 = geompy.addToStudy(face1, "Face1")

# create a circle to be an extrusion path
px1 = geompy.MakeVertex( 100.,  100.,  0.)
py1 = geompy.MakeVertex(-100., -100.,  0.)
pz1 = geompy.MakeVertex(   0.,    0., 50.)

circle = geompy.MakeCircleThreePnt(py1, pz1, px1)
id_circle = geompy.addToStudy(circle, "Path")
 
# create a 2D mesh on the face
trias = smesh.Mesh(face1, "Face : 2D mesh")

algo1D = trias.Segment()
algo1D.NumberOfSegments(6)
algo2D = trias.Triangle()
algo2D.LengthFromEdges()

trias.Compute()

# create a path mesh
circlemesh = smesh.Mesh(circle, "Path mesh")
algo = circlemesh.Segment()
algo.NumberOfSegments(10)
circlemesh.Compute()

# extrusion of the mesh
trias.ExtrusionAlongPath([], circlemesh, circle,
                         1, 0, [], 0, smesh.PointStruct(0, 0, 0))

# merge nodes
print "Number of nodes before MergeNodes:", 
trias.NbNodes()
tolerance = 0.001
array_of_nodes_groups = trias.FindCoincidentNodes(tolerance)

trias.MergeNodes(array_of_nodes_groups)

print "Number of nodes after MergeNodes:", trias.NbNodes()
print ""
print "Number of elements before MergeEqualElements:"
print "Edges      : ", trias.NbEdges()
print "Triangles  : ", trias.NbTriangles()
print "Quadrangles: ", trias.NbQuadrangles()
print "Volumes    : ", trias.NbVolumes()

# merge elements
trias.MergeEqualElements()
print "Number of elements after MergeEqualElements:"
print "Edges      : ", trias.NbEdges()
print "Triangles  : ", trias.NbTriangles()
print "Quadrangles: ", trias.NbQuadrangles()
print "Volumes    : ", trias.NbVolumes()

salome.sg.updateObjBrowser(1)
\endcode

<br><h2>Sewing Meshes</h2>

<br>
\anchor tui_sew_meshes_border_to_side
<h3>Sew Meshes Border to Side</h3>

\code
import geompy
import smesh

# create two faces of a box
box1 = geompy.MakeBox(0., 0., -10., 30., 20., 25.)
facesList1 = geompy.SubShapeAll(box1, geompy.ShapeType["FACE"])
face1 = facesList1[2]

box2 = geompy.MakeBox(0., 5., 0., 20., 20., 15.)
facesList2 = geompy.SubShapeAll(box2, geompy.ShapeType["FACE"])
face2 = facesList2[1]

edgesList = geompy.SubShapeAll(face2, geompy.ShapeType["EDGE"])
edge1 = edgesList[2]

aComp = geompy.MakeCompound([face1, face2])
geompy.addToStudy(aComp, "Two faces")

# create a mesh on two faces
mesh = smesh.Mesh(aComp, "Two faces : quadrangle mesh")

algo1D = mesh.Segment()
algo1D.NumberOfSegments(9)
algo2D = mesh.Quadrangle()

algo_local = mesh.Segment(edge1)
algo_local.Arithmetic1D(1, 4)
algo_local.Propagation()

mesh.Compute()

# sew border to side
# FirstNodeIDOnFreeBorder, SecondNodeIDOnFreeBorder, LastNodeIDOnFreeBorder,
# FirstNodeIDOnSide, LastNodeIDOnSide,
# CreatePolygons, CreatePolyedrs
mesh.SewBorderToSide(5, 45, 6, 113, 109, 0, 0)
\endcode

<br>
\anchor tui_sew_conform_free_borders
<h3>Sew Conform Free Borders</h3>

\code
import geompy
import smesh

# create two faces of the box
box1 = geompy.MakeBox(0., 0., -10., 20., 20., 15.)
facesList1 = geompy.SubShapeAll(box1, geompy.ShapeType["FACE"])
face1 = facesList1[2]

box2 = geompy.MakeBox(0., 5., 0., 20., 20., 15.)
facesList2 = geompy.SubShapeAll(box2, geompy.ShapeType["FACE"])
face2 = facesList2[1]

edgesList = geompy.SubShapeAll(face2, geompy.ShapeType["EDGE"])
edge1 = edgesList[2]

aComp = geompy.MakeCompound([face1, face2])
geompy.addToStudy(aComp, "Two faces")

# create a mesh on two faces
mesh = smesh.Mesh(aComp, "Two faces : quadrangle mesh")

algo1D = mesh.Segment()
algo1D.NumberOfSegments(9)
algo2D = mesh.Quadrangle()

algo_local = mesh.Segment(edge1)
algo_local.Arithmetic1D(1, 4)
algo_local.Propagation()

mesh.Compute()

# sew conform free borders
# FirstNodeID1, SecondNodeID1, LastNodeID1, FirstNodeID2, SecondNodeID2
mesh.SewConformFreeBorders(5, 45, 6, 3, 24) 
\endcode

<br>
\anchor tui_sew_free_borders
<h3>Sew Free Borders</h3>

\code
import geompy
import smesh

# create two faces of the box
box1 = geompy.MakeBox(0., 0., 0., 20., 20., 15.)
facesList1 = geompy.SubShapeAll(box1, geompy.ShapeType["FACE"])
face1 = facesList1[2]

box2 = geompy.MakeBox(0., 5., 0., 20., 20., 15.)
facesList2 = geompy.SubShapeAll(box2, geompy.ShapeType["FACE"])
face2 = facesList2[1]

edgesList = geompy.SubShapeAll(face2, geompy.ShapeType["EDGE"])
edge1 = edgesList[2]

aComp = geompy.MakeCompound([face1, face2])
geompy.addToStudy(aComp, "Two faces")

# create a mesh on two faces
mesh = smesh.Mesh(aComp, "Two faces : quadrangle mesh")

algo1D = mesh.Segment()
algo1D.NumberOfSegments(4)
algo2D = mesh.Quadrangle()

algo_local = mesh.Segment(edge1)
algo_local.Arithmetic1D(1, 4)
algo_local.Propagation()

mesh.Compute()

# sew free borders
# FirstNodeID1, SecondNodeID1, LastNodeID1,
# FirstNodeID2, SecondNodeID2, LastNodeID2, CreatePolygons, CreatePolyedrs
mesh.SewFreeBorders(6, 21, 5, 1, 12, 3, 0, 0)
\endcode

<br>
\anchor tui_sew_side_elements
<h3>Sew Side Elements</h3>

\code
import geompy
import smesh

# create two boxes
box1 = geompy.MakeBox(0.,  0., 0., 10., 10., 10.)
box2 = geompy.MakeBox(0., 15., 0., 20., 25., 10.)

EdgesList = geompy.SubShapeAll(box2, geompy.ShapeType["EDGE"])

aComp = geompy.MakeCompound([box1, box2])
geompy.addToStudy(aComp, "Two boxes")

# create a mesh on two boxes
mesh = smesh.Mesh(aComp, "Two faces : quadrangle mesh")

algo1D = mesh.Segment()
algo1D.NumberOfSegments(2)
algo2D = mesh.Quadrangle()

algo_local = mesh.Segment(EdgesList[8])
algo_local.NumberOfSegments(4)
algo_local.Propagation()

mesh.Compute()

# sew side elements
# IDsOfSide1Elements, IDsOfSide2Elements,
# NodeID1OfSide1ToMerge, NodeID1OfSide2ToMerge, NodeID2OfSide1ToMerge, NodeID2OfSide2ToMerge
mesh.SewSideElements([69, 70, 71, 72], [91, 92, 89, 90], 8, 38, 23, 58)
\endcode

<br>
\anchor tui_duplicate_nodes
<h3>Duplicate nodes</h3>

\code
import salome
import smesh
import SMESH_test1

mesh = SMESH_test1.mesh

# Compute mesh
mesh.Compute()

# Without the duplication of border elements

# Nodes to duplicate
nodes1 = mesh.CreateEmptyGroup( smesh.NODE, 'nodes1' )
nodes1.Add( [ 289, 278, 302, 285 ] )

# Group of faces to replace nodes with new ones 
faces1 = mesh.CreateEmptyGroup( smesh.FACE, 'faces1' )
faces1.Add( [ 519, 556, 557 ] )

# Duplicate nodes
print "\nMesh before the first nodes duplication:"
print "Nodes      : ", mesh.NbNodes()
print "Edges      : ", mesh.NbEdges()
print "Triangles  : ", mesh.NbTriangles()

groupOfCreatedNodes = mesh.DoubleNodeGroup(nodes1, faces1, theMakeGroup=True)
print "New nodes:", groupOfCreatedNodes.GetIDs()

print "\nMesh after the first nodes duplication:"
print "Nodes      : ", mesh.NbNodes()
print "Edges      : ", mesh.NbEdges()
print "Triangles  : ", mesh.NbTriangles()

# With the duplication of border elements

# Edges to duplicate
edges = mesh.CreateEmptyGroup( smesh.EDGE, 'edges' )
edges.Add( [ 29, 30, 31 ] )

# Nodes not to duplicate
nodes2 = mesh.CreateEmptyGroup( smesh.NODE, 'nodes2' )
nodes2.Add( [ 32, 5 ] )

# Group of faces to replace nodes with new ones 
faces2 = mesh.CreateEmptyGroup( smesh.FACE, 'faces2' )
faces2.Add( [ 576, 578, 580 ] )

# Duplicate nodes
print "\nMesh before the second nodes duplication:"
print "Nodes      : ", mesh.NbNodes()
print "Edges      : ", mesh.NbEdges()
print "Triangles  : ", mesh.NbTriangles()

groupOfNewEdges = mesh.DoubleNodeElemGroup( edges, nodes2, faces2, theMakeGroup=True )
print "New edges:", groupOfNewEdges.GetIDs()

print "\nMesh after the second nodes duplication:"
print "Nodes      : ", mesh.NbNodes()
print "Edges      : ", mesh.NbEdges()
print "Triangles  : ", mesh.NbTriangles()

# Update object browser
if salome.sg.hasDesktop():
    salome.sg.updateObjBrowser(0)
\endcode

<br>
\anchor tui_make_2dmesh_from_3d
<h3>Create boundary elements</h3>

\code
# The objective of these samples is to illustrate the following use cases:
# 1) The mesh MESH1 with 3D cells has no or only a part of its skin (2D cells):
#    1.1) Add the 2D skin (missing 2D cells) to MESH1 (what is done now by the algorithm).
#    1.2) Create a new 3D Mesh MESH2 that consists of MESH1 and added 2D skin cells.
#    1.3) Create a new 2D Mesh MESH3 that consists only of 2D skin cells.
# 2) The mesh MESH1 with 3D cells has all its skin (2D cells):
#    Create a new 2D Mesh MESH3 that consists only of 2D skin cells.
#
# In all cases an option to create a group containing these 2D skin cells is available.

from smesh import *

box = geompy.MakeBoxDXDYDZ(1,1,1)
geompy.addToStudy(box,"box")
boxFace = geompy.SubShapeAll(box, geompy.ShapeType["FACE"])[0]
geompy.addToStudyInFather(box,boxFace,"boxFace")

MESH1 = Mesh(box,"MESH1")
MESH1.AutomaticHexahedralization()

init_nb_edges = MESH1.NbEdges()
init_nb_faces = MESH1.NbFaces()
init_nb_volumes = MESH1.NbVolumes()

# =========================================================================================
# 1) The mesh MESH1 with 3D cells has no or only a part of its skin (2D cells)
# =========================================================================================
# remove some faces
all_faces = MESH1.GetElementsByType(SMESH.FACE)
rm_faces = all_faces[:init_nb_faces/5] + all_faces[4*init_nb_faces/5:]
MESH1.RemoveElements(rm_faces)
assert(MESH1.NbFaces() == init_nb_faces-len(rm_faces))

# 1.1) Add the 2D skin (missing 2D cells) to MESH1
# -------------------------------------------------
# add missing faces
# 1.1.1) to the whole mesh
m,g = MESH1.MakeBoundaryMesh(MESH1)
assert(init_nb_faces == MESH1.NbFaces())
assert(init_nb_edges == MESH1.NbEdges())
assert(m)
assert(not g)

# 1.1.2) to some elements
MESH1.RemoveElements(rm_faces)
MESH1.MakeBoundaryMesh([])
assert(init_nb_faces != MESH1.NbFaces())
volumes = MESH1.GetElementsByType(SMESH.VOLUME)
for v in volumes:
    MESH1.MakeBoundaryMesh([v])
assert(init_nb_faces == MESH1.NbFaces())
assert(init_nb_edges == MESH1.NbEdges())

# 1.1.3) to a group of elements
volGroup1 = MESH1.CreateEmptyGroup(SMESH.VOLUME, "volGroup1")
volGroup1.Add( volumes[: init_nb_volumes/2])
volGroup2 = MESH1.CreateEmptyGroup(SMESH.VOLUME, "volGroup2")
volGroup1.Add( volumes[init_nb_volumes/2:])
MESH1.RemoveElements(rm_faces)
MESH1.MakeBoundaryMesh(volGroup1)
MESH1.MakeBoundaryMesh(volGroup2)
assert(init_nb_faces == MESH1.NbFaces())
assert(init_nb_edges == MESH1.NbEdges())

# 1.1.4) to a submesh.
# The submesh has no volumes, so it is required to check if it passes without crash and does not create
# missing faces
faceSubmesh = MESH1.GetSubMesh( boxFace, "boxFace" )
MESH1.RemoveElements(rm_faces)
MESH1.MakeBoundaryMesh(faceSubmesh)
assert(init_nb_faces != MESH1.NbFaces())

# check group creation
MESH1.RemoveElements(rm_faces)
groupName = "added to mesh"
m,group = MESH1.MakeBoundaryMesh(MESH1,groupName=groupName)
assert(group)
assert(group.GetName() == groupName)
assert(group.Size() == len(rm_faces))


# 1.2) Create a new 3D Mesh MESH2 that consists of MESH1 and added 2D skin cells.
# ------------------------------------------------------------------------------
MESH1.RemoveElements(rm_faces)
meshName = "MESH2"
MESH2,group = MESH1.MakeBoundaryMesh(MESH1,meshName=meshName,toCopyElements=True)
assert(MESH2)
assert(MESH2.GetName() == meshName)
assert(MESH2.NbVolumes() == MESH1.NbVolumes())
assert(MESH2.NbFaces() == len(rm_faces))

# check group creation
MESH1.RemoveElements(rm_faces)
MESH2,group = MESH1.MakeBoundaryMesh(MESH1,meshName="MESH2_0",
                                     groupName=groupName,toCopyElements=True)
assert(group)
assert(group.GetName() == groupName)
assert(group.Size() == len(rm_faces))
assert(group.GetMesh()._is_equivalent(MESH2.GetMesh()))

# 1.3) Create a new 2D Mesh MESH3 that consists only of 2D skin cells.
# -----------------------------------------------------------------------
MESH1.RemoveElements(rm_faces)
meshName = "MESH3"
MESH3,group = MESH1.MakeBoundaryMesh(MESH1,meshName=meshName,toCopyExistingBondary=True)
assert(MESH3)
assert(not group)
assert(MESH3.GetName() == meshName)
assert(MESH3.NbVolumes() == 0)
assert(MESH3.NbFaces() == init_nb_faces)

# check group creation
MESH1.RemoveElements(rm_faces)
MESH3,group = MESH1.MakeBoundaryMesh(MESH1,meshName=meshName,
                                     groupName=groupName, toCopyExistingBondary=True)
assert(group)
assert(group.GetName() == groupName)
assert(group.Size() == len(rm_faces))
assert(group.GetMesh()._is_equivalent(MESH3.GetMesh()))
assert(MESH3.NbFaces() == init_nb_faces)

# ==================================================================
# 2) The mesh MESH1 with 3D cells has all its skin (2D cells)
# Create a new 2D Mesh MESH3 that consists only of 2D skin cells.
# ==================================================================
MESH1.MakeBoundaryMesh(MESH1)
MESH3,group = MESH1.MakeBoundaryMesh(MESH1,meshName=meshName,toCopyExistingBondary=True)
assert(MESH3)
assert(not group)
assert(MESH3.NbVolumes() == 0)
assert(MESH3.NbFaces() == init_nb_faces)

# check group creation
MESH3,group = MESH1.MakeBoundaryMesh(MESH1,meshName=meshName,
                                     groupName=groupName, toCopyExistingBondary=True)
assert(group)
assert(group.GetName() == groupName)
assert(group.Size() == 0)
assert(group.GetMesh()._is_equivalent(MESH3.GetMesh()))
assert(MESH3.NbFaces() == init_nb_faces)

# ================
# Make 1D from 2D
# ================

MESH1.Clear()
MESH1.Compute()
MESH1.RemoveElements( MESH1.GetElementsByType(SMESH.EDGE))

rm_faces = faceSubmesh.GetIDs()[:2] # to remove few adjacent faces
nb_missing_edges = 2 + 2*len(rm_faces)

MESH1.RemoveElements(rm_faces)
mesh,group = MESH1.MakeBoundaryMesh(MESH1, BND_1DFROM2D)
assert( MESH1.NbEdges() == nb_missing_edges )


\endcode
*/
